#!/bin/bash

usage() {
        (( $# > 0 )) && echo $@
        echo "USAGE: ${0##*/} [-h] [-l LOG] [start|end|list|edit] [ENTRY COMMENT]"
        cat <<-EOF

				-l    Overrides the default log

				Using the 'list' command pretty-prints all log entries.
				If no arguments are given, this is the default command.

				The 'edit' command opens the log in vim.

				Using the 'start' command when there is an ongoing entry
				will split that entry by ending it and starting a new one.

				The 'ENTRY COMMENT' is added to the entry when the 'end'
				command is called or when the 'start' command is splitting
				an entry. It's ignored by the other commands.
EOF
} >&2

log="$HOME/.hours"
while getopts :hl: opt; do
    case $opt in
        l) log=$OPTARG ;;
        h) usage; exit 0 ;;
        \?) usage "ERROR: Invalid argument: -$OPTARG" ; exit 1 ;;
    esac
done
shift $((OPTIND-1))

: ${log:?"ERROR: No log file defined"}
if [[ ! -f "${log}" ]]; then
    touch "${log}"
    echo "Created new log file"
fi

isOngoingEntry() { ## ongoing entry == 11 bytes
    return $( [[ -s ${log} ]] && (( $(tail -1 "${log}" | wc -c) <= 11 )) )
}

if (( $# > 0 )); then
    case $1 in
        start|s)
            isOngoingEntry && "$0" ${log:+-l ${log}} end ${@:2} || exit 3 # Split ongoing entry
            echo -n "$(date +%s)" >> "${log}"
            echo "Started entry at: $(date +'%F %T')"
            ;;
        end|e)
            isOngoingEntry || {
                echo "ERROR: Did not find entry to end" >&2
                exit 3
            }
            [[ -z $(tail -c 1 "${log}") ]] && truncate -s -1 "${log}" # Fix for the extra newline issue
            msg="${@:2}"
            printf " %s%s\n" $(date +%s) "${msg:+" ${msg}"}" >> "${log}"
            echo "Ended entry at: $(date +'%F %T')"
            ;;
        list|l)  exec $0 ${log:+-l ${log}} ;;
        edit|ed) exec gvim ${log} ;;
        *)  usage "ERROR: Unrecognized command: $1"; exit 1 ;;
    esac
else
    awk '
    function getDurationStr(secs) { # returns hh:mm
        return sprintf("%02d:%02d", (secs/3600), (secs%3600/60))
    }

    function printDailyTotal(count, duration) {
        if (count > 1) {
            printf("   \033[33mTotal: %s\033[0m\n", getDurationStr(duration))
        }
    }

    # Ignore commented lines
    /^[[:space:]]*#/ { next }

    # Fake out the current session
    NF == 1 {
        $0 = sprintf("%d %d \033[1;32mONGOING\033[0m", $0, strftime("%s"))
    }

    NF > 1 {
        day = strftime("%Y%m%d", $1)

        # Print a newline between the entries of a single day
        if (prevDay != day) {
            if (prevDay) {
                printDailyTotal(dailyCount, dailyDuration)
                printf("\n")
            }
            prevDay = day
            dailyCount = daily = 0
        }

        # Aggregate the daily hours
        duration = $2-$1
        dailyDuration += duration
        dailyCount += 1

        # Print the entry and then anything else at the end as a "label"
        printf("%s: %s", day, getDurationStr(duration))
        if (NF > 2) {
            $1 = $2 = ""
            printf(" [%s]", gensub(/^[[:space:]]*/, "", "g"))
        }
        printf("\n")
    }

    # Catch the last grouping that needs to be totaled
    END {
        printDailyTotal(dailyCount, dailyDuration)
    }
    ' "${log}"
fi
