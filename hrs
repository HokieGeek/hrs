#!/bin/bash

badOngoingEntryBytes="12"
log="$HOME/.hours"
cfg="$HOME/.hrs.conf"

usage() {
        (( $# > 0 )) && echo $@
        echo "USAGE: ${0##*/} [-h] [-l LOG] [start|end|list|edit|watch|raw] [ENTRY COMMENT]"

        cat <<-EOF

				Using the 'list' command pretty-prints all log entries.
				If no arguments are given, this is the default command.

				The 'raw' command dumps the log's contents.
				The 'edit' command opens the log in vim.

				Using the 'start' command when there is an ongoing entry
				will split that entry by ending it and starting a new one.

				The 'ENTRY COMMENT' is added to the entry when the 'end'
				command is called. The 'start' command only uses it when
				splitting an entry. It's ignored by the other commands.
EOF
} >&2

if [[ -f "${cfg}" ]]; then
    source <(awk -F'=' '
                /^#/ { next }
                NF > 1 && $2 !~ /^[[:space:]"'"'"']*$/ {
                    sub(/^ */, "", $2)
                    printf("%s=%s\n", $1, $2)
                }
                ' "${cfg}")
fi

while getopts :hl: opt; do
    case $opt in
        l) log=$OPTARG ;;
        h) usage; exit 0 ;;
    esac
done
shift $((OPTIND-1))

: ${log:?"ERROR: No log file defined"}
if [[ ! -f "${log}" ]]; then
    touch "${log}"
    echo "Created new log file"
fi

fixOngoingEntry() {
    local last=$(tail -1 "${log}")
    sed -i '$d' "${log}"
    echo -n "${last}" >> "${log}"
}

getLastEntryBytes() {
    [[ ! -s "${log}" ]] && echo "0"
    echo "$(tail -1 "${log}" | wc -c)"
}

if (( $# > 0 )); then
    case $1 in
        start|s|st|sta|star)
            if [[ -s ${log} ]] && (( $(getLastEntryBytes) <= ${badOngoingEntryBytes} )); then
                echo "Splitting ongoing entry..."
                shift
                "$0" end $@ || exit 3
            fi
            echo -n "$(date +%s) " >> "${log}"
            echo "Started entry at: $(date +'%F %T')"
            ;;
        end|e|en)
            ongoingEntryBytes=$(getLastEntryBytes)
            if (( ${ongoingEntryBytes} <= ${badOngoingEntryBytes} )); then
                (( ${ongoingEntryBytes} == ${badOngoingEntryBytes} )) && fixOngoingEntry
                {
                    echo -n "$(date +%s)"
                    if (( $# > 1 )); then
                        shift
                        echo -n " $@"
                    fi
                    echo ""
                } >> "${log}"
            else
                echo "ERROR: Did not find entry to end" >&2
                exit 3
            fi
            echo "Ended entry at: $(date +'%F %T')"
            echo -n "Ellapsed time: "
            "$0" | awk '$1 ~ /^[0-9]{8}:/ { last=$2 } END { print last }'
            ;;
        watch|w|wa|wat|watc)
            exec watch -t "$0 | awk '/ONGOING/ { print \$2 }'"
            ;;
        edit|ed|edi)
            vim "${log}"
            (( $(getLastEntryBytes) == ${badOngoingEntryBytes} )) && fixOngoingEntry
            ;;
        raw|r|ra)
            exec cat "${log}"
            ;;
        list|l|li|lis)
            exec "$0" ${log:+-l ${log}}
            ;;
        *)  usage "ERROR: Unrecognized command: $1"
            exit 1
            ;;
    esac
else
    awk '
    function printDailyTotal(DAY,   dailySecs) {
        dailySecs = daily[DAY]-68400;
        printf("   \033[33mTotal: %s\033[0m\n", strftime("%H:%M", dailySecs))
    }

    # Ignore commented lines
    /^#/ { next }

    # Fake out the current session
    NF == 1 {
        $0 = $0 strftime("%s") " \033[1;32mONGOING\033[0m"
    }

    NF > 1 {
        # Aggregate the daily hours
        secs = $2-$1
        day = strftime("%Y%m%d", $1)
        daily[day] += secs
        dailyCount[day] += 1

        # Print a newline between the entries of a single day
        if (prevDay != day) {
            if (prevDay != "" && dailyCount[prevDay] > 1) {
                printDailyTotal(prevDay)
            }
            printf("\n")
            prevDay = day
        }

        # Ok, print the entry nicely
        secs -= 68400;
        printf("%s: %s", day, strftime("%H:%M", secs))

        # Print anything else at the end as a "label"
        if (NF > 2) {
            $1 = ""
            $2 = ""
            sub(/^ */, "")
            printf(" [%s]", $0)
        }
        printf("\n")
    }

    # Catch the last grouping that needs to be totaled
    END {
        if (dailyCount[day] > 1) {
            printDailyTotal(day)
        }
    }
    ' "${log}"
fi
