#!/usr/bin/awk -f

BEGIN {
    ## Default values
    cmds["start"]=cmds["s"]=cmds["st"]="start"
    cmds["end"]=cmds["e"]="end"
    cmds["list"]=cmds["l"]="list"
    logpath=(ENVIRON["HOME"] "/.hours")

    ## Handle any switches
    cmdPos=1
    while (ARGV[cmdPos] ~ /^-/) {
        if (ARGV[cmdPos] ~ /^--log?/) {
            logpath=ARGV[++cmdPos]
        }
        cmdPos++
    }

    ## Handle the command
    cmd=tolower(ARGV[cmdPos])
    if (cmd ~ /l(ist)?/ || !cmd) {
        ARGV[1]=logpath
        ARGC=2
    } else if (cmd in cmds) {
        if (ARGC-1 > cmdPos) {
            for (msgPos=cmdPos+1; msgPos < ARGC; msgPos++) {
                msg=sprintf("%s %s", msg, ARGV[msgPos])
            }
            sub(/^[[:space:]]*/, "", msg)
        }
        ARGC=1
        addCommand(cmd)
    } else {
        print "USAGE: hrs [--log LOG] [list | [start|end] [ENTRY COMMENT]]" > "/dev/stderr"
        print "\n       If no arguments are given, 'list' is the default command." > "/dev/stderr"
        print "\n       Using the 'start' command when there is an ongoing entry" > "/dev/stderr"
        print "       will end it and start a new one." > "/dev/stderr"
        exit 1
    }
}

function addCommand(cmd) {
    ARGV[ARGC]=("/tmp/hrs." PROCINFO["pid"] "." ARGC)
    print cmds[cmd] > ARGV[ARGC]
    close(ARGV[ARGC])
    tempfiles=sprintf("%s %s", tempfiles, ARGV[ARGC]) ## Store to delete later
    ARGC++
}

function isOngoingEntry() {
    while(getline < logpath);
    close(logpath)
    return length() == 10 ## ongoing entry is 10 bytes w/o newline
}

function getDurationStr(secs) { # returns hh:mm
    return sprintf("%02d:%02d", (secs/3600), (secs%3600/60))
}

function printDailyTotal(count, duration) {
    if (count > 1) {
        printf("   \033[33mTotal: %s\033[0m\n", getDurationStr(duration))
    }
}

/^start/ {
    if (isOngoingEntry()) {
        addCommand("end")
        addCommand("start")
    } else {
        printf("%s", strftime("%s")) >> logpath
        close(logpath)
        printf("Started entry at: %s\n", strftime("%F %T"))
    }
    next
}

/^end/ {
    if (isOngoingEntry()) {
        # Fix for the extra newline issue TODO: mostly awk solution would be better
        system(sprintf("[ -z \"`tail -c 1 %s`\" ] && truncate -s -1 %s", logpath, logpath))

        $1 = sprintf(" %s", strftime("%s"))
        if (msg) $2 = msg
        print >> logpath
        close(logpath)

        printf("Ended entry at: %s\n", strftime("%F %T"))
    } else {
        print "ERROR: Did not find entry to end" > "/dev/stderr"
    }
    next
}

# Ignore commented lines
/^[[:space:]]*#/ { next }

# Fake out the current session
NF == 1 {
    $0 = sprintf("%d %d \033[1;32mONGOING\033[0m", $0, strftime("%s"))
}

NF > 1 {
    day = strftime("%Y%m%d", $1)

    # Print a newline between the entries of a single day
    if (prevDay != day) {
        if (prevDay) {
            printDailyTotal(dailyCount, dailyDuration)
            printf("\n")
        }
        prevDay = day
        dailyCount = daily = 0
    }

    # Aggregate the daily hours
    duration = $2-$1
    dailyDuration += duration
    dailyCount += 1

    # Print the entry and then anything else at the end as a "label"
    printf("%s: %s", day, getDurationStr(duration))
    if (NF > 2) {
        $1 = $2 = ""
        printf(" [%s]", gensub(/^[[:space:]]*/, "", "g"))
    }
    printf("\n")
}

# Catch the last grouping that needs to be totaled
END {
    printDailyTotal(dailyCount, dailyDuration)

    if (tempfiles) {
        system(sprintf("rm -f %s", tempfiles))
    }
}
